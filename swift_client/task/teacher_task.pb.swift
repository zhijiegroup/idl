// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: task/teacher_task.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct GloryApi_TeacherTaskParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var taskParameterID: Int64 = 0

  var taskParameterKey: String = String()

  var taskParameterName: String = String()

  var taskParameterOperator: String = String()

  var taskParameterValue: String = String()

  var taskParameterType: String = String()

  var children: [GloryApi_TeacherTaskParameter] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GloryApi_TeacherTaskClass {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: Int64 = 0

  var className: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GloryApi_TeacherTaskAttachment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ossPath: String = String()

  var ossURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GloryApi_TeacherTask {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 教师任务 ID
  var teacherTaskID: Int64 {
    get {return _storage._teacherTaskID}
    set {_uniqueStorage()._teacherTaskID = newValue}
  }

  /// 教师 ID
  var teacherID: Int64 {
    get {return _storage._teacherID}
    set {_uniqueStorage()._teacherID = newValue}
  }

  /// 教师任务名称
  var teacherTaskName: String {
    get {return _storage._teacherTaskName}
    set {_uniqueStorage()._teacherTaskName = newValue}
  }

  /// 教师任务所属业务系统
  var teacherTaskBusiness: String {
    get {return _storage._teacherTaskBusiness}
    set {_uniqueStorage()._teacherTaskBusiness = newValue}
  }

  /// 任务分配班级
  var teacherTaskClasses: [GloryApi_TeacherTaskClass] {
    get {return _storage._teacherTaskClasses}
    set {_uniqueStorage()._teacherTaskClasses = newValue}
  }

  /// 任务开始时间
  var teacherTaskStart: String {
    get {return _storage._teacherTaskStart}
    set {_uniqueStorage()._teacherTaskStart = newValue}
  }

  /// 任务结束时间
  var teacherTaskEnd: String {
    get {return _storage._teacherTaskEnd}
    set {_uniqueStorage()._teacherTaskEnd = newValue}
  }

  /// 任务类型：1.模板任务；2.手动任务
  var teacherTaskType: Int32 {
    get {return _storage._teacherTaskType}
    set {_uniqueStorage()._teacherTaskType = newValue}
  }

  /// 任务使用的模板 ID
  var teacherTaskTemplateID: Int64 {
    get {return _storage._teacherTaskTemplateID}
    set {_uniqueStorage()._teacherTaskTemplateID = newValue}
  }

  /// 预置任务表示
  var systemTaskKey: String {
    get {return _storage._systemTaskKey}
    set {_uniqueStorage()._systemTaskKey = newValue}
  }

  /// 任务内容
  var teacherTaskContent: String {
    get {return _storage._teacherTaskContent}
    set {_uniqueStorage()._teacherTaskContent = newValue}
  }

  /// 任务要求
  var teacherTaskRequirements: [String] {
    get {return _storage._teacherTaskRequirements}
    set {_uniqueStorage()._teacherTaskRequirements = newValue}
  }

  /// 任务链接
  var teacherTaskLink: String {
    get {return _storage._teacherTaskLink}
    set {_uniqueStorage()._teacherTaskLink = newValue}
  }

  /// 任务状态：not_started：未开始；ongoing：进行中；ended：已结束
  var teacherTaskStatus: String {
    get {return _storage._teacherTaskStatus}
    set {_uniqueStorage()._teacherTaskStatus = newValue}
  }

  /// 总任务数
  var totalTaskCount: Int64 {
    get {return _storage._totalTaskCount}
    set {_uniqueStorage()._totalTaskCount = newValue}
  }

  /// 总提交数
  var totalSubmitCount: Int64 {
    get {return _storage._totalSubmitCount}
    set {_uniqueStorage()._totalSubmitCount = newValue}
  }

  /// 总通过数
  var totalPassCount: Int64 {
    get {return _storage._totalPassCount}
    set {_uniqueStorage()._totalPassCount = newValue}
  }

  /// 任务参数
  var taskParameters: [GloryApi_TeacherTaskParameter] {
    get {return _storage._taskParameters}
    set {_uniqueStorage()._taskParameters = newValue}
  }

  var teacherTaskTemplate: GloryApi_TeacherTaskTemplate {
    get {return _storage._teacherTaskTemplate ?? GloryApi_TeacherTaskTemplate()}
    set {_uniqueStorage()._teacherTaskTemplate = newValue}
  }
  /// Returns true if `teacherTaskTemplate` has been explicitly set.
  var hasTeacherTaskTemplate: Bool {return _storage._teacherTaskTemplate != nil}
  /// Clears the value of `teacherTaskTemplate`. Subsequent reads from it will return its default value.
  mutating func clearTeacherTaskTemplate() {_uniqueStorage()._teacherTaskTemplate = nil}

  var createdAt: String {
    get {return _storage._createdAt}
    set {_uniqueStorage()._createdAt = newValue}
  }

  var updatedAt: String {
    get {return _storage._updatedAt}
    set {_uniqueStorage()._updatedAt = newValue}
  }

  var creator: GloryApi_User {
    get {return _storage._creator ?? GloryApi_User()}
    set {_uniqueStorage()._creator = newValue}
  }
  /// Returns true if `creator` has been explicitly set.
  var hasCreator: Bool {return _storage._creator != nil}
  /// Clears the value of `creator`. Subsequent reads from it will return its default value.
  mutating func clearCreator() {_uniqueStorage()._creator = nil}

  var updator: GloryApi_User {
    get {return _storage._updator ?? GloryApi_User()}
    set {_uniqueStorage()._updator = newValue}
  }
  /// Returns true if `updator` has been explicitly set.
  var hasUpdator: Bool {return _storage._updator != nil}
  /// Clears the value of `updator`. Subsequent reads from it will return its default value.
  mutating func clearUpdator() {_uniqueStorage()._updator = nil}

  var teacherTaskAttachments: [GloryApi_TeacherTaskAttachment] {
    get {return _storage._teacherTaskAttachments}
    set {_uniqueStorage()._teacherTaskAttachments = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct GloryApi_TeacherTaskProgress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 任务状态：not_started：未开始；ongoing：进行中；ended：已结束
  var teacherTaskStatus: String = String()

  /// 任务评价类型：1. 仅机器评分；2. 仅老师评分；3. 包含机器与老师
  var teacherTaskEvaluateType: Int32 = 0

  /// 任务总参与人数
  var totalTaskCount: Int64 = 0

  /// 学生提交任务数
  var studentSubmitCount: Int64 = 0

  /// 学生未提交任务数
  var studentNotSubmitCount: Int64 = 0

  /// 机器评价任务数
  var systemEvaluatedCount: Int64 = 0

  /// 机器待评价任务数
  var systemNotEvaluatedCount: Int64 = 0

  /// 老师评价任务数
  var teacherEvaluatedCount: Int64 = 0

  /// 老师待评价任务数
  var teacherNotEvaluatedCount: Int64 = 0

  /// 整体完成评价数
  var totalEvaluatedCount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GloryApi_CreateTeacherTaskRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseRequest: Base_BaseRequest {
    get {return _baseRequest ?? Base_BaseRequest()}
    set {_baseRequest = newValue}
  }
  /// Returns true if `baseRequest` has been explicitly set.
  var hasBaseRequest: Bool {return self._baseRequest != nil}
  /// Clears the value of `baseRequest`. Subsequent reads from it will return its default value.
  mutating func clearBaseRequest() {self._baseRequest = nil}

  var teacherTask: GloryApi_TeacherTask {
    get {return _teacherTask ?? GloryApi_TeacherTask()}
    set {_teacherTask = newValue}
  }
  /// Returns true if `teacherTask` has been explicitly set.
  var hasTeacherTask: Bool {return self._teacherTask != nil}
  /// Clears the value of `teacherTask`. Subsequent reads from it will return its default value.
  mutating func clearTeacherTask() {self._teacherTask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseRequest: Base_BaseRequest? = nil
  fileprivate var _teacherTask: GloryApi_TeacherTask? = nil
}

struct GloryApi_CreateTeacherTaskResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
}

struct GloryApi_UpdateTeacherTaskRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseRequest: Base_BaseRequest {
    get {return _baseRequest ?? Base_BaseRequest()}
    set {_baseRequest = newValue}
  }
  /// Returns true if `baseRequest` has been explicitly set.
  var hasBaseRequest: Bool {return self._baseRequest != nil}
  /// Clears the value of `baseRequest`. Subsequent reads from it will return its default value.
  mutating func clearBaseRequest() {self._baseRequest = nil}

  var teacherTask: GloryApi_TeacherTask {
    get {return _teacherTask ?? GloryApi_TeacherTask()}
    set {_teacherTask = newValue}
  }
  /// Returns true if `teacherTask` has been explicitly set.
  var hasTeacherTask: Bool {return self._teacherTask != nil}
  /// Clears the value of `teacherTask`. Subsequent reads from it will return its default value.
  mutating func clearTeacherTask() {self._teacherTask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseRequest: Base_BaseRequest? = nil
  fileprivate var _teacherTask: GloryApi_TeacherTask? = nil
}

struct GloryApi_UpdateTeacherTaskResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
}

struct GloryApi_ListTeacherTaskRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseRequest: Base_BaseRequest {
    get {return _baseRequest ?? Base_BaseRequest()}
    set {_baseRequest = newValue}
  }
  /// Returns true if `baseRequest` has been explicitly set.
  var hasBaseRequest: Bool {return self._baseRequest != nil}
  /// Clears the value of `baseRequest`. Subsequent reads from it will return its default value.
  mutating func clearBaseRequest() {self._baseRequest = nil}

  var keyword: String = String()

  var classID: Int64 = 0

  /// 任务状态: not_started: 未开始; ongoing: 进行中; ended: 已结束
  var status: String = String()

  /// 任务创建时间开始
  var createdStart: String = String()

  /// 任务创建时间结束
  var createdEnd: String = String()

  var pagination: Base_PaginationRequest {
    get {return _pagination ?? Base_PaginationRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseRequest: Base_BaseRequest? = nil
  fileprivate var _pagination: Base_PaginationRequest? = nil
}

struct GloryApi_ListTeacherTaskResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  var teacherTasks: [GloryApi_TeacherTask] = []

  var pagination: Base_PaginationResponse {
    get {return _pagination ?? Base_PaginationResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
  fileprivate var _pagination: Base_PaginationResponse? = nil
}

struct GloryApi_GetTeacherTaskRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseRequest: Base_BaseRequest {
    get {return _baseRequest ?? Base_BaseRequest()}
    set {_baseRequest = newValue}
  }
  /// Returns true if `baseRequest` has been explicitly set.
  var hasBaseRequest: Bool {return self._baseRequest != nil}
  /// Clears the value of `baseRequest`. Subsequent reads from it will return its default value.
  mutating func clearBaseRequest() {self._baseRequest = nil}

  var teacherTaskID: Int64 = 0

  var copy: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseRequest: Base_BaseRequest? = nil
}

struct GloryApi_GetTeacherTaskResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  var teacherTask: GloryApi_TeacherTask {
    get {return _teacherTask ?? GloryApi_TeacherTask()}
    set {_teacherTask = newValue}
  }
  /// Returns true if `teacherTask` has been explicitly set.
  var hasTeacherTask: Bool {return self._teacherTask != nil}
  /// Clears the value of `teacherTask`. Subsequent reads from it will return its default value.
  mutating func clearTeacherTask() {self._teacherTask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
  fileprivate var _teacherTask: GloryApi_TeacherTask? = nil
}

struct GloryApi_GetTeacherTaskProgressRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseRequest: Base_BaseRequest {
    get {return _baseRequest ?? Base_BaseRequest()}
    set {_baseRequest = newValue}
  }
  /// Returns true if `baseRequest` has been explicitly set.
  var hasBaseRequest: Bool {return self._baseRequest != nil}
  /// Clears the value of `baseRequest`. Subsequent reads from it will return its default value.
  mutating func clearBaseRequest() {self._baseRequest = nil}

  var teacherTaskID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseRequest: Base_BaseRequest? = nil
}

struct GloryApi_GetTeacherTaskProgressResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  var teacherTaskProgress: GloryApi_TeacherTaskProgress {
    get {return _teacherTaskProgress ?? GloryApi_TeacherTaskProgress()}
    set {_teacherTaskProgress = newValue}
  }
  /// Returns true if `teacherTaskProgress` has been explicitly set.
  var hasTeacherTaskProgress: Bool {return self._teacherTaskProgress != nil}
  /// Clears the value of `teacherTaskProgress`. Subsequent reads from it will return its default value.
  mutating func clearTeacherTaskProgress() {self._teacherTaskProgress = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
  fileprivate var _teacherTaskProgress: GloryApi_TeacherTaskProgress? = nil
}

struct GloryApi_DeleteTeacherTaskRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseRequest: Base_BaseRequest {
    get {return _baseRequest ?? Base_BaseRequest()}
    set {_baseRequest = newValue}
  }
  /// Returns true if `baseRequest` has been explicitly set.
  var hasBaseRequest: Bool {return self._baseRequest != nil}
  /// Clears the value of `baseRequest`. Subsequent reads from it will return its default value.
  mutating func clearBaseRequest() {self._baseRequest = nil}

  var teacherTaskID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseRequest: Base_BaseRequest? = nil
}

struct GloryApi_DeleteTeacherTaskResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
}

struct GloryApi_ClassTaskCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var type: String = String()

  var data: [Float] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GloryApi_ClassTaskSubmitCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `class`: String = String()

  var task: String = String()

  var classTotal: Int32 = 0

  var noSubmit: Int32 = 0

  var submitted: Int32 = 0

  var expiry: Int32 = 0

  var submitPercent: String = String()

  var submitPercentValue: Float = 0

  var taskID: Int64 = 0

  var classID: Int64 = 0

  var createdAt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GloryApi_ClassTaskPassCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `class`: String = String()

  var task: String = String()

  var classTotal: Int32 = 0

  var submitted: Int32 = 0

  var passed: Int32 = 0

  var noPass: Int32 = 0

  var passPercent: String = String()

  var passPercentValue: Float = 0

  var taskID: Int64 = 0

  var classID: Int64 = 0

  var createdAt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GloryApi_StudentSubmitCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var `class`: String = String()

  var submit: String = String()

  var submitValue: Float = 0

  var taskTotal: Int64 = 0

  var taskNoSubmit: Int64 = 0

  var taskSubmitted: Int64 = 0

  var taskExpired: Int64 = 0

  var avatar: String = String()

  var studentID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GloryApi_StudentPassCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var `class`: String = String()

  var pass: String = String()

  var passValue: Float = 0

  var taskTotal: Int64 = 0

  var taskNoSubmit: Int64 = 0

  var taskSubmitted: Int64 = 0

  var taskPassed: Int64 = 0

  var taskNoPassed: Int64 = 0

  var avatar: String = String()

  var studentID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GloryApi_CountTeacherTaskRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseRequest: Base_BaseRequest {
    get {return _baseRequest ?? Base_BaseRequest()}
    set {_baseRequest = newValue}
  }
  /// Returns true if `baseRequest` has been explicitly set.
  var hasBaseRequest: Bool {return self._baseRequest != nil}
  /// Clears the value of `baseRequest`. Subsequent reads from it will return its default value.
  mutating func clearBaseRequest() {self._baseRequest = nil}

  var systemName: [String] = []

  var classID: [Int64] = []

  var beginDate: String = String()

  var endDate: String = String()

  var name: String = String()

  var pagination: Base_PaginationRequest {
    get {return _pagination ?? Base_PaginationRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseRequest: Base_BaseRequest? = nil
  fileprivate var _pagination: Base_PaginationRequest? = nil
}

struct GloryApi_CountClassSubmitResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  var legend: [String] = []

  var categories: [String] = []

  /// 班级任务提交统计
  var classData: [GloryApi_ClassTaskCount] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
}

struct GloryApi_CountPositiveListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  /// 学习积极分子排行榜
  var positiveList: [GloryApi_StudentSubmitCount] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
}

struct GloryApi_CountPotentialListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  /// 进度潜力学生排行榜
  var potentialList: [GloryApi_StudentSubmitCount] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
}

struct GloryApi_CountSubmitListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  /// 学生任务提交统计
  var list: [GloryApi_StudentSubmitCount] = []

  var pagination: Base_PaginationResponse {
    get {return _pagination ?? Base_PaginationResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
  fileprivate var _pagination: Base_PaginationResponse? = nil
}

struct GloryApi_CountPassListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  /// 学生任务提交统计
  var list: [GloryApi_StudentPassCount] = []

  var pagination: Base_PaginationResponse {
    get {return _pagination ?? Base_PaginationResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
  fileprivate var _pagination: Base_PaginationResponse? = nil
}

struct GloryApi_CountClassPassResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  var legend: [String] = []

  var categories: [String] = []

  /// 班级任务通过统计
  var classData: [GloryApi_ClassTaskCount] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
}

struct GloryApi_CountSuperStudentListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  /// 学习积极分子排行榜
  var superList: [GloryApi_StudentPassCount] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
}

struct GloryApi_CountLaggingStudentListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  /// 学习积极分子排行榜
  var laggingList: [GloryApi_StudentPassCount] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
}

struct GloryApi_CountClassSubmitListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  var list: [GloryApi_ClassTaskSubmitCount] = []

  var pagination: Base_PaginationResponse {
    get {return _pagination ?? Base_PaginationResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
  fileprivate var _pagination: Base_PaginationResponse? = nil
}

struct GloryApi_CountClassPassListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  var list: [GloryApi_ClassTaskPassCount] = []

  var pagination: Base_PaginationResponse {
    get {return _pagination ?? Base_PaginationResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
  fileprivate var _pagination: Base_PaginationResponse? = nil
}

struct GloryApi_TeacherTaskStatsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseRequest: Base_BaseRequest {
    get {return _baseRequest ?? Base_BaseRequest()}
    set {_baseRequest = newValue}
  }
  /// Returns true if `baseRequest` has been explicitly set.
  var hasBaseRequest: Bool {return self._baseRequest != nil}
  /// Clears the value of `baseRequest`. Subsequent reads from it will return its default value.
  mutating func clearBaseRequest() {self._baseRequest = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseRequest: Base_BaseRequest? = nil
}

struct GloryApi_TeacherTaskStatsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  var totalTaskCount: Int64 = 0

  var notStartedCount: Int64 = 0

  var ongoingCount: Int64 = 0

  var endedCount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
}

struct GloryApi_ListTaskStudentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseRequest: Base_BaseRequest {
    get {return _baseRequest ?? Base_BaseRequest()}
    set {_baseRequest = newValue}
  }
  /// Returns true if `baseRequest` has been explicitly set.
  var hasBaseRequest: Bool {return self._baseRequest != nil}
  /// Clears the value of `baseRequest`. Subsequent reads from it will return its default value.
  mutating func clearBaseRequest() {self._baseRequest = nil}

  var taskID: Int64 = 0

  var noSubmitClassID: [Int64] = []

  var submittedClassID: [Int64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseRequest: Base_BaseRequest? = nil
}

struct GloryApi_TaskStudent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var userID: Int64 = 0

  var taskID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GloryApi_ListTaskStudentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  var noSubmitList: [GloryApi_TaskStudent] = []

  var submittedList: [GloryApi_TaskStudent] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension GloryApi_TeacherTaskParameter: @unchecked Sendable {}
extension GloryApi_TeacherTaskClass: @unchecked Sendable {}
extension GloryApi_TeacherTaskAttachment: @unchecked Sendable {}
extension GloryApi_TeacherTask: @unchecked Sendable {}
extension GloryApi_TeacherTaskProgress: @unchecked Sendable {}
extension GloryApi_CreateTeacherTaskRequest: @unchecked Sendable {}
extension GloryApi_CreateTeacherTaskResponse: @unchecked Sendable {}
extension GloryApi_UpdateTeacherTaskRequest: @unchecked Sendable {}
extension GloryApi_UpdateTeacherTaskResponse: @unchecked Sendable {}
extension GloryApi_ListTeacherTaskRequest: @unchecked Sendable {}
extension GloryApi_ListTeacherTaskResponse: @unchecked Sendable {}
extension GloryApi_GetTeacherTaskRequest: @unchecked Sendable {}
extension GloryApi_GetTeacherTaskResponse: @unchecked Sendable {}
extension GloryApi_GetTeacherTaskProgressRequest: @unchecked Sendable {}
extension GloryApi_GetTeacherTaskProgressResponse: @unchecked Sendable {}
extension GloryApi_DeleteTeacherTaskRequest: @unchecked Sendable {}
extension GloryApi_DeleteTeacherTaskResponse: @unchecked Sendable {}
extension GloryApi_ClassTaskCount: @unchecked Sendable {}
extension GloryApi_ClassTaskSubmitCount: @unchecked Sendable {}
extension GloryApi_ClassTaskPassCount: @unchecked Sendable {}
extension GloryApi_StudentSubmitCount: @unchecked Sendable {}
extension GloryApi_StudentPassCount: @unchecked Sendable {}
extension GloryApi_CountTeacherTaskRequest: @unchecked Sendable {}
extension GloryApi_CountClassSubmitResponse: @unchecked Sendable {}
extension GloryApi_CountPositiveListResponse: @unchecked Sendable {}
extension GloryApi_CountPotentialListResponse: @unchecked Sendable {}
extension GloryApi_CountSubmitListResponse: @unchecked Sendable {}
extension GloryApi_CountPassListResponse: @unchecked Sendable {}
extension GloryApi_CountClassPassResponse: @unchecked Sendable {}
extension GloryApi_CountSuperStudentListResponse: @unchecked Sendable {}
extension GloryApi_CountLaggingStudentListResponse: @unchecked Sendable {}
extension GloryApi_CountClassSubmitListResponse: @unchecked Sendable {}
extension GloryApi_CountClassPassListResponse: @unchecked Sendable {}
extension GloryApi_TeacherTaskStatsRequest: @unchecked Sendable {}
extension GloryApi_TeacherTaskStatsResponse: @unchecked Sendable {}
extension GloryApi_ListTaskStudentRequest: @unchecked Sendable {}
extension GloryApi_TaskStudent: @unchecked Sendable {}
extension GloryApi_ListTaskStudentResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "glory_api"

extension GloryApi_TeacherTaskParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TeacherTaskParameter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_parameter_id"),
    2: .standard(proto: "task_parameter_key"),
    3: .standard(proto: "task_parameter_name"),
    4: .standard(proto: "task_parameter_operator"),
    5: .standard(proto: "task_parameter_value"),
    6: .standard(proto: "task_parameter_type"),
    7: .same(proto: "children"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.taskParameterID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.taskParameterKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.taskParameterName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.taskParameterOperator) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.taskParameterValue) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.taskParameterType) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.children) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.taskParameterID != 0 {
      try visitor.visitSingularInt64Field(value: self.taskParameterID, fieldNumber: 1)
    }
    if !self.taskParameterKey.isEmpty {
      try visitor.visitSingularStringField(value: self.taskParameterKey, fieldNumber: 2)
    }
    if !self.taskParameterName.isEmpty {
      try visitor.visitSingularStringField(value: self.taskParameterName, fieldNumber: 3)
    }
    if !self.taskParameterOperator.isEmpty {
      try visitor.visitSingularStringField(value: self.taskParameterOperator, fieldNumber: 4)
    }
    if !self.taskParameterValue.isEmpty {
      try visitor.visitSingularStringField(value: self.taskParameterValue, fieldNumber: 5)
    }
    if !self.taskParameterType.isEmpty {
      try visitor.visitSingularStringField(value: self.taskParameterType, fieldNumber: 6)
    }
    if !self.children.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.children, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_TeacherTaskParameter, rhs: GloryApi_TeacherTaskParameter) -> Bool {
    if lhs.taskParameterID != rhs.taskParameterID {return false}
    if lhs.taskParameterKey != rhs.taskParameterKey {return false}
    if lhs.taskParameterName != rhs.taskParameterName {return false}
    if lhs.taskParameterOperator != rhs.taskParameterOperator {return false}
    if lhs.taskParameterValue != rhs.taskParameterValue {return false}
    if lhs.taskParameterType != rhs.taskParameterType {return false}
    if lhs.children != rhs.children {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_TeacherTaskClass: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TeacherTaskClass"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
    2: .standard(proto: "class_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.classID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.className) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.classID != 0 {
      try visitor.visitSingularInt64Field(value: self.classID, fieldNumber: 1)
    }
    if !self.className.isEmpty {
      try visitor.visitSingularStringField(value: self.className, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_TeacherTaskClass, rhs: GloryApi_TeacherTaskClass) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.className != rhs.className {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_TeacherTaskAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TeacherTaskAttachment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "oss_path"),
    2: .standard(proto: "oss_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ossPath) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ossURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ossPath.isEmpty {
      try visitor.visitSingularStringField(value: self.ossPath, fieldNumber: 1)
    }
    if !self.ossURL.isEmpty {
      try visitor.visitSingularStringField(value: self.ossURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_TeacherTaskAttachment, rhs: GloryApi_TeacherTaskAttachment) -> Bool {
    if lhs.ossPath != rhs.ossPath {return false}
    if lhs.ossURL != rhs.ossURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_TeacherTask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TeacherTask"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "teacher_task_id"),
    2: .standard(proto: "teacher_id"),
    3: .standard(proto: "teacher_task_name"),
    4: .standard(proto: "teacher_task_business"),
    5: .standard(proto: "teacher_task_classes"),
    6: .standard(proto: "teacher_task_start"),
    7: .standard(proto: "teacher_task_end"),
    8: .standard(proto: "teacher_task_type"),
    9: .standard(proto: "teacher_task_template_id"),
    10: .standard(proto: "system_task_key"),
    11: .standard(proto: "teacher_task_content"),
    12: .standard(proto: "teacher_task_requirements"),
    13: .standard(proto: "teacher_task_link"),
    14: .standard(proto: "teacher_task_status"),
    15: .standard(proto: "total_task_count"),
    16: .standard(proto: "total_submit_count"),
    17: .standard(proto: "total_pass_count"),
    18: .standard(proto: "task_parameters"),
    19: .standard(proto: "teacher_task_template"),
    20: .standard(proto: "created_at"),
    21: .standard(proto: "updated_at"),
    22: .same(proto: "creator"),
    23: .same(proto: "updator"),
    24: .standard(proto: "teacher_task_attachments"),
  ]

  fileprivate class _StorageClass {
    var _teacherTaskID: Int64 = 0
    var _teacherID: Int64 = 0
    var _teacherTaskName: String = String()
    var _teacherTaskBusiness: String = String()
    var _teacherTaskClasses: [GloryApi_TeacherTaskClass] = []
    var _teacherTaskStart: String = String()
    var _teacherTaskEnd: String = String()
    var _teacherTaskType: Int32 = 0
    var _teacherTaskTemplateID: Int64 = 0
    var _systemTaskKey: String = String()
    var _teacherTaskContent: String = String()
    var _teacherTaskRequirements: [String] = []
    var _teacherTaskLink: String = String()
    var _teacherTaskStatus: String = String()
    var _totalTaskCount: Int64 = 0
    var _totalSubmitCount: Int64 = 0
    var _totalPassCount: Int64 = 0
    var _taskParameters: [GloryApi_TeacherTaskParameter] = []
    var _teacherTaskTemplate: GloryApi_TeacherTaskTemplate? = nil
    var _createdAt: String = String()
    var _updatedAt: String = String()
    var _creator: GloryApi_User? = nil
    var _updator: GloryApi_User? = nil
    var _teacherTaskAttachments: [GloryApi_TeacherTaskAttachment] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _teacherTaskID = source._teacherTaskID
      _teacherID = source._teacherID
      _teacherTaskName = source._teacherTaskName
      _teacherTaskBusiness = source._teacherTaskBusiness
      _teacherTaskClasses = source._teacherTaskClasses
      _teacherTaskStart = source._teacherTaskStart
      _teacherTaskEnd = source._teacherTaskEnd
      _teacherTaskType = source._teacherTaskType
      _teacherTaskTemplateID = source._teacherTaskTemplateID
      _systemTaskKey = source._systemTaskKey
      _teacherTaskContent = source._teacherTaskContent
      _teacherTaskRequirements = source._teacherTaskRequirements
      _teacherTaskLink = source._teacherTaskLink
      _teacherTaskStatus = source._teacherTaskStatus
      _totalTaskCount = source._totalTaskCount
      _totalSubmitCount = source._totalSubmitCount
      _totalPassCount = source._totalPassCount
      _taskParameters = source._taskParameters
      _teacherTaskTemplate = source._teacherTaskTemplate
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
      _creator = source._creator
      _updator = source._updator
      _teacherTaskAttachments = source._teacherTaskAttachments
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._teacherTaskID) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._teacherID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._teacherTaskName) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._teacherTaskBusiness) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._teacherTaskClasses) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._teacherTaskStart) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._teacherTaskEnd) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._teacherTaskType) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._teacherTaskTemplateID) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._systemTaskKey) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._teacherTaskContent) }()
        case 12: try { try decoder.decodeRepeatedStringField(value: &_storage._teacherTaskRequirements) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._teacherTaskLink) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._teacherTaskStatus) }()
        case 15: try { try decoder.decodeSingularInt64Field(value: &_storage._totalTaskCount) }()
        case 16: try { try decoder.decodeSingularInt64Field(value: &_storage._totalSubmitCount) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._totalPassCount) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._taskParameters) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._teacherTaskTemplate) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._createdAt) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._updatedAt) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._creator) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._updator) }()
        case 24: try { try decoder.decodeRepeatedMessageField(value: &_storage._teacherTaskAttachments) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._teacherTaskID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._teacherTaskID, fieldNumber: 1)
      }
      if _storage._teacherID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._teacherID, fieldNumber: 2)
      }
      if !_storage._teacherTaskName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._teacherTaskName, fieldNumber: 3)
      }
      if !_storage._teacherTaskBusiness.isEmpty {
        try visitor.visitSingularStringField(value: _storage._teacherTaskBusiness, fieldNumber: 4)
      }
      if !_storage._teacherTaskClasses.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._teacherTaskClasses, fieldNumber: 5)
      }
      if !_storage._teacherTaskStart.isEmpty {
        try visitor.visitSingularStringField(value: _storage._teacherTaskStart, fieldNumber: 6)
      }
      if !_storage._teacherTaskEnd.isEmpty {
        try visitor.visitSingularStringField(value: _storage._teacherTaskEnd, fieldNumber: 7)
      }
      if _storage._teacherTaskType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._teacherTaskType, fieldNumber: 8)
      }
      if _storage._teacherTaskTemplateID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._teacherTaskTemplateID, fieldNumber: 9)
      }
      if !_storage._systemTaskKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._systemTaskKey, fieldNumber: 10)
      }
      if !_storage._teacherTaskContent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._teacherTaskContent, fieldNumber: 11)
      }
      if !_storage._teacherTaskRequirements.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._teacherTaskRequirements, fieldNumber: 12)
      }
      if !_storage._teacherTaskLink.isEmpty {
        try visitor.visitSingularStringField(value: _storage._teacherTaskLink, fieldNumber: 13)
      }
      if !_storage._teacherTaskStatus.isEmpty {
        try visitor.visitSingularStringField(value: _storage._teacherTaskStatus, fieldNumber: 14)
      }
      if _storage._totalTaskCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalTaskCount, fieldNumber: 15)
      }
      if _storage._totalSubmitCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalSubmitCount, fieldNumber: 16)
      }
      if _storage._totalPassCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalPassCount, fieldNumber: 17)
      }
      if !_storage._taskParameters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._taskParameters, fieldNumber: 18)
      }
      try { if let v = _storage._teacherTaskTemplate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      if !_storage._createdAt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createdAt, fieldNumber: 20)
      }
      if !_storage._updatedAt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._updatedAt, fieldNumber: 21)
      }
      try { if let v = _storage._creator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._updator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      if !_storage._teacherTaskAttachments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._teacherTaskAttachments, fieldNumber: 24)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_TeacherTask, rhs: GloryApi_TeacherTask) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._teacherTaskID != rhs_storage._teacherTaskID {return false}
        if _storage._teacherID != rhs_storage._teacherID {return false}
        if _storage._teacherTaskName != rhs_storage._teacherTaskName {return false}
        if _storage._teacherTaskBusiness != rhs_storage._teacherTaskBusiness {return false}
        if _storage._teacherTaskClasses != rhs_storage._teacherTaskClasses {return false}
        if _storage._teacherTaskStart != rhs_storage._teacherTaskStart {return false}
        if _storage._teacherTaskEnd != rhs_storage._teacherTaskEnd {return false}
        if _storage._teacherTaskType != rhs_storage._teacherTaskType {return false}
        if _storage._teacherTaskTemplateID != rhs_storage._teacherTaskTemplateID {return false}
        if _storage._systemTaskKey != rhs_storage._systemTaskKey {return false}
        if _storage._teacherTaskContent != rhs_storage._teacherTaskContent {return false}
        if _storage._teacherTaskRequirements != rhs_storage._teacherTaskRequirements {return false}
        if _storage._teacherTaskLink != rhs_storage._teacherTaskLink {return false}
        if _storage._teacherTaskStatus != rhs_storage._teacherTaskStatus {return false}
        if _storage._totalTaskCount != rhs_storage._totalTaskCount {return false}
        if _storage._totalSubmitCount != rhs_storage._totalSubmitCount {return false}
        if _storage._totalPassCount != rhs_storage._totalPassCount {return false}
        if _storage._taskParameters != rhs_storage._taskParameters {return false}
        if _storage._teacherTaskTemplate != rhs_storage._teacherTaskTemplate {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._creator != rhs_storage._creator {return false}
        if _storage._updator != rhs_storage._updator {return false}
        if _storage._teacherTaskAttachments != rhs_storage._teacherTaskAttachments {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_TeacherTaskProgress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TeacherTaskProgress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "teacher_task_status"),
    2: .standard(proto: "teacher_task_evaluate_type"),
    3: .standard(proto: "total_task_count"),
    4: .standard(proto: "student_submit_count"),
    5: .standard(proto: "student_not_submit_count"),
    6: .standard(proto: "system_evaluated_count"),
    7: .standard(proto: "system_not_evaluated_count"),
    8: .standard(proto: "teacher_evaluated_count"),
    9: .standard(proto: "teacher_not_evaluated_count"),
    10: .standard(proto: "total_evaluated_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.teacherTaskStatus) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.teacherTaskEvaluateType) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.totalTaskCount) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.studentSubmitCount) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.studentNotSubmitCount) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.systemEvaluatedCount) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.systemNotEvaluatedCount) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.teacherEvaluatedCount) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.teacherNotEvaluatedCount) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.totalEvaluatedCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.teacherTaskStatus.isEmpty {
      try visitor.visitSingularStringField(value: self.teacherTaskStatus, fieldNumber: 1)
    }
    if self.teacherTaskEvaluateType != 0 {
      try visitor.visitSingularInt32Field(value: self.teacherTaskEvaluateType, fieldNumber: 2)
    }
    if self.totalTaskCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalTaskCount, fieldNumber: 3)
    }
    if self.studentSubmitCount != 0 {
      try visitor.visitSingularInt64Field(value: self.studentSubmitCount, fieldNumber: 4)
    }
    if self.studentNotSubmitCount != 0 {
      try visitor.visitSingularInt64Field(value: self.studentNotSubmitCount, fieldNumber: 5)
    }
    if self.systemEvaluatedCount != 0 {
      try visitor.visitSingularInt64Field(value: self.systemEvaluatedCount, fieldNumber: 6)
    }
    if self.systemNotEvaluatedCount != 0 {
      try visitor.visitSingularInt64Field(value: self.systemNotEvaluatedCount, fieldNumber: 7)
    }
    if self.teacherEvaluatedCount != 0 {
      try visitor.visitSingularInt64Field(value: self.teacherEvaluatedCount, fieldNumber: 8)
    }
    if self.teacherNotEvaluatedCount != 0 {
      try visitor.visitSingularInt64Field(value: self.teacherNotEvaluatedCount, fieldNumber: 9)
    }
    if self.totalEvaluatedCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalEvaluatedCount, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_TeacherTaskProgress, rhs: GloryApi_TeacherTaskProgress) -> Bool {
    if lhs.teacherTaskStatus != rhs.teacherTaskStatus {return false}
    if lhs.teacherTaskEvaluateType != rhs.teacherTaskEvaluateType {return false}
    if lhs.totalTaskCount != rhs.totalTaskCount {return false}
    if lhs.studentSubmitCount != rhs.studentSubmitCount {return false}
    if lhs.studentNotSubmitCount != rhs.studentNotSubmitCount {return false}
    if lhs.systemEvaluatedCount != rhs.systemEvaluatedCount {return false}
    if lhs.systemNotEvaluatedCount != rhs.systemNotEvaluatedCount {return false}
    if lhs.teacherEvaluatedCount != rhs.teacherEvaluatedCount {return false}
    if lhs.teacherNotEvaluatedCount != rhs.teacherNotEvaluatedCount {return false}
    if lhs.totalEvaluatedCount != rhs.totalEvaluatedCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_CreateTeacherTaskRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateTeacherTaskRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_request"),
    2: .standard(proto: "teacher_task"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseRequest) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._teacherTask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._teacherTask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_CreateTeacherTaskRequest, rhs: GloryApi_CreateTeacherTaskRequest) -> Bool {
    if lhs._baseRequest != rhs._baseRequest {return false}
    if lhs._teacherTask != rhs._teacherTask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_CreateTeacherTaskResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateTeacherTaskResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_CreateTeacherTaskResponse, rhs: GloryApi_CreateTeacherTaskResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_UpdateTeacherTaskRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateTeacherTaskRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_request"),
    2: .standard(proto: "teacher_task"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseRequest) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._teacherTask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._teacherTask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_UpdateTeacherTaskRequest, rhs: GloryApi_UpdateTeacherTaskRequest) -> Bool {
    if lhs._baseRequest != rhs._baseRequest {return false}
    if lhs._teacherTask != rhs._teacherTask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_UpdateTeacherTaskResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateTeacherTaskResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_UpdateTeacherTaskResponse, rhs: GloryApi_UpdateTeacherTaskResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_ListTeacherTaskRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTeacherTaskRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_request"),
    2: .same(proto: "keyword"),
    3: .standard(proto: "class_id"),
    4: .same(proto: "status"),
    5: .standard(proto: "created_start"),
    6: .standard(proto: "created_end"),
    100: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseRequest) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keyword) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.classID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.createdStart) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.createdEnd) }()
      case 100: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.keyword.isEmpty {
      try visitor.visitSingularStringField(value: self.keyword, fieldNumber: 2)
    }
    if self.classID != 0 {
      try visitor.visitSingularInt64Field(value: self.classID, fieldNumber: 3)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 4)
    }
    if !self.createdStart.isEmpty {
      try visitor.visitSingularStringField(value: self.createdStart, fieldNumber: 5)
    }
    if !self.createdEnd.isEmpty {
      try visitor.visitSingularStringField(value: self.createdEnd, fieldNumber: 6)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_ListTeacherTaskRequest, rhs: GloryApi_ListTeacherTaskRequest) -> Bool {
    if lhs._baseRequest != rhs._baseRequest {return false}
    if lhs.keyword != rhs.keyword {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.createdStart != rhs.createdStart {return false}
    if lhs.createdEnd != rhs.createdEnd {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_ListTeacherTaskResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTeacherTaskResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
    2: .standard(proto: "teacher_tasks"),
    100: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.teacherTasks) }()
      case 100: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.teacherTasks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.teacherTasks, fieldNumber: 2)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_ListTeacherTaskResponse, rhs: GloryApi_ListTeacherTaskResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs.teacherTasks != rhs.teacherTasks {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_GetTeacherTaskRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTeacherTaskRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_request"),
    2: .standard(proto: "teacher_task_id"),
    3: .same(proto: "copy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseRequest) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.teacherTaskID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.copy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.teacherTaskID != 0 {
      try visitor.visitSingularInt64Field(value: self.teacherTaskID, fieldNumber: 2)
    }
    if self.copy != false {
      try visitor.visitSingularBoolField(value: self.copy, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_GetTeacherTaskRequest, rhs: GloryApi_GetTeacherTaskRequest) -> Bool {
    if lhs._baseRequest != rhs._baseRequest {return false}
    if lhs.teacherTaskID != rhs.teacherTaskID {return false}
    if lhs.copy != rhs.copy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_GetTeacherTaskResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTeacherTaskResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
    2: .standard(proto: "teacher_task"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._teacherTask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._teacherTask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_GetTeacherTaskResponse, rhs: GloryApi_GetTeacherTaskResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs._teacherTask != rhs._teacherTask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_GetTeacherTaskProgressRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTeacherTaskProgressRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_request"),
    2: .standard(proto: "teacher_task_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseRequest) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.teacherTaskID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.teacherTaskID != 0 {
      try visitor.visitSingularInt64Field(value: self.teacherTaskID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_GetTeacherTaskProgressRequest, rhs: GloryApi_GetTeacherTaskProgressRequest) -> Bool {
    if lhs._baseRequest != rhs._baseRequest {return false}
    if lhs.teacherTaskID != rhs.teacherTaskID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_GetTeacherTaskProgressResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTeacherTaskProgressResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
    2: .standard(proto: "teacher_task_progress"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._teacherTaskProgress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._teacherTaskProgress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_GetTeacherTaskProgressResponse, rhs: GloryApi_GetTeacherTaskProgressResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs._teacherTaskProgress != rhs._teacherTaskProgress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_DeleteTeacherTaskRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteTeacherTaskRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_request"),
    2: .standard(proto: "teacher_task_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseRequest) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.teacherTaskID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.teacherTaskID != 0 {
      try visitor.visitSingularInt64Field(value: self.teacherTaskID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_DeleteTeacherTaskRequest, rhs: GloryApi_DeleteTeacherTaskRequest) -> Bool {
    if lhs._baseRequest != rhs._baseRequest {return false}
    if lhs.teacherTaskID != rhs.teacherTaskID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_DeleteTeacherTaskResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteTeacherTaskResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_DeleteTeacherTaskResponse, rhs: GloryApi_DeleteTeacherTaskResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_ClassTaskCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClassTaskCount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeRepeatedFloatField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitPackedFloatField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_ClassTaskCount, rhs: GloryApi_ClassTaskCount) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_ClassTaskSubmitCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClassTaskSubmitCount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "class"),
    2: .same(proto: "task"),
    3: .standard(proto: "class_total"),
    4: .standard(proto: "no_submit"),
    5: .same(proto: "submitted"),
    6: .same(proto: "expiry"),
    7: .standard(proto: "submit_percent"),
    8: .standard(proto: "submit_percent_value"),
    10: .standard(proto: "task_id"),
    11: .standard(proto: "class_id"),
    12: .standard(proto: "created_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.`class`) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.task) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.classTotal) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.noSubmit) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.submitted) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.expiry) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.submitPercent) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.submitPercentValue) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.taskID) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.classID) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.`class`.isEmpty {
      try visitor.visitSingularStringField(value: self.`class`, fieldNumber: 1)
    }
    if !self.task.isEmpty {
      try visitor.visitSingularStringField(value: self.task, fieldNumber: 2)
    }
    if self.classTotal != 0 {
      try visitor.visitSingularInt32Field(value: self.classTotal, fieldNumber: 3)
    }
    if self.noSubmit != 0 {
      try visitor.visitSingularInt32Field(value: self.noSubmit, fieldNumber: 4)
    }
    if self.submitted != 0 {
      try visitor.visitSingularInt32Field(value: self.submitted, fieldNumber: 5)
    }
    if self.expiry != 0 {
      try visitor.visitSingularInt32Field(value: self.expiry, fieldNumber: 6)
    }
    if !self.submitPercent.isEmpty {
      try visitor.visitSingularStringField(value: self.submitPercent, fieldNumber: 7)
    }
    if self.submitPercentValue != 0 {
      try visitor.visitSingularFloatField(value: self.submitPercentValue, fieldNumber: 8)
    }
    if self.taskID != 0 {
      try visitor.visitSingularInt64Field(value: self.taskID, fieldNumber: 10)
    }
    if self.classID != 0 {
      try visitor.visitSingularInt64Field(value: self.classID, fieldNumber: 11)
    }
    if !self.createdAt.isEmpty {
      try visitor.visitSingularStringField(value: self.createdAt, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_ClassTaskSubmitCount, rhs: GloryApi_ClassTaskSubmitCount) -> Bool {
    if lhs.`class` != rhs.`class` {return false}
    if lhs.task != rhs.task {return false}
    if lhs.classTotal != rhs.classTotal {return false}
    if lhs.noSubmit != rhs.noSubmit {return false}
    if lhs.submitted != rhs.submitted {return false}
    if lhs.expiry != rhs.expiry {return false}
    if lhs.submitPercent != rhs.submitPercent {return false}
    if lhs.submitPercentValue != rhs.submitPercentValue {return false}
    if lhs.taskID != rhs.taskID {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_ClassTaskPassCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClassTaskPassCount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "class"),
    2: .same(proto: "task"),
    3: .standard(proto: "class_total"),
    4: .same(proto: "submitted"),
    5: .same(proto: "passed"),
    6: .standard(proto: "no_pass"),
    7: .standard(proto: "pass_percent"),
    8: .standard(proto: "pass_percent_value"),
    10: .standard(proto: "task_id"),
    11: .standard(proto: "class_id"),
    12: .standard(proto: "created_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.`class`) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.task) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.classTotal) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.submitted) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.passed) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.noPass) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.passPercent) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.passPercentValue) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.taskID) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.classID) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.`class`.isEmpty {
      try visitor.visitSingularStringField(value: self.`class`, fieldNumber: 1)
    }
    if !self.task.isEmpty {
      try visitor.visitSingularStringField(value: self.task, fieldNumber: 2)
    }
    if self.classTotal != 0 {
      try visitor.visitSingularInt32Field(value: self.classTotal, fieldNumber: 3)
    }
    if self.submitted != 0 {
      try visitor.visitSingularInt32Field(value: self.submitted, fieldNumber: 4)
    }
    if self.passed != 0 {
      try visitor.visitSingularInt32Field(value: self.passed, fieldNumber: 5)
    }
    if self.noPass != 0 {
      try visitor.visitSingularInt32Field(value: self.noPass, fieldNumber: 6)
    }
    if !self.passPercent.isEmpty {
      try visitor.visitSingularStringField(value: self.passPercent, fieldNumber: 7)
    }
    if self.passPercentValue != 0 {
      try visitor.visitSingularFloatField(value: self.passPercentValue, fieldNumber: 8)
    }
    if self.taskID != 0 {
      try visitor.visitSingularInt64Field(value: self.taskID, fieldNumber: 10)
    }
    if self.classID != 0 {
      try visitor.visitSingularInt64Field(value: self.classID, fieldNumber: 11)
    }
    if !self.createdAt.isEmpty {
      try visitor.visitSingularStringField(value: self.createdAt, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_ClassTaskPassCount, rhs: GloryApi_ClassTaskPassCount) -> Bool {
    if lhs.`class` != rhs.`class` {return false}
    if lhs.task != rhs.task {return false}
    if lhs.classTotal != rhs.classTotal {return false}
    if lhs.submitted != rhs.submitted {return false}
    if lhs.passed != rhs.passed {return false}
    if lhs.noPass != rhs.noPass {return false}
    if lhs.passPercent != rhs.passPercent {return false}
    if lhs.passPercentValue != rhs.passPercentValue {return false}
    if lhs.taskID != rhs.taskID {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_StudentSubmitCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StudentSubmitCount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "class"),
    3: .same(proto: "submit"),
    4: .standard(proto: "submit_value"),
    5: .standard(proto: "task_total"),
    6: .standard(proto: "task_no_submit"),
    7: .standard(proto: "task_submitted"),
    8: .standard(proto: "task_expired"),
    10: .same(proto: "avatar"),
    11: .standard(proto: "student_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.`class`) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.submit) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.submitValue) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.taskTotal) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.taskNoSubmit) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.taskSubmitted) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.taskExpired) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.studentID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.`class`.isEmpty {
      try visitor.visitSingularStringField(value: self.`class`, fieldNumber: 2)
    }
    if !self.submit.isEmpty {
      try visitor.visitSingularStringField(value: self.submit, fieldNumber: 3)
    }
    if self.submitValue != 0 {
      try visitor.visitSingularFloatField(value: self.submitValue, fieldNumber: 4)
    }
    if self.taskTotal != 0 {
      try visitor.visitSingularInt64Field(value: self.taskTotal, fieldNumber: 5)
    }
    if self.taskNoSubmit != 0 {
      try visitor.visitSingularInt64Field(value: self.taskNoSubmit, fieldNumber: 6)
    }
    if self.taskSubmitted != 0 {
      try visitor.visitSingularInt64Field(value: self.taskSubmitted, fieldNumber: 7)
    }
    if self.taskExpired != 0 {
      try visitor.visitSingularInt64Field(value: self.taskExpired, fieldNumber: 8)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 10)
    }
    if self.studentID != 0 {
      try visitor.visitSingularInt64Field(value: self.studentID, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_StudentSubmitCount, rhs: GloryApi_StudentSubmitCount) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.`class` != rhs.`class` {return false}
    if lhs.submit != rhs.submit {return false}
    if lhs.submitValue != rhs.submitValue {return false}
    if lhs.taskTotal != rhs.taskTotal {return false}
    if lhs.taskNoSubmit != rhs.taskNoSubmit {return false}
    if lhs.taskSubmitted != rhs.taskSubmitted {return false}
    if lhs.taskExpired != rhs.taskExpired {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.studentID != rhs.studentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_StudentPassCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StudentPassCount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "class"),
    3: .same(proto: "pass"),
    4: .standard(proto: "pass_value"),
    5: .standard(proto: "task_total"),
    6: .standard(proto: "task_no_submit"),
    7: .standard(proto: "task_submitted"),
    8: .standard(proto: "task_passed"),
    9: .standard(proto: "task_no_passed"),
    10: .same(proto: "avatar"),
    11: .standard(proto: "student_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.`class`) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pass) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.passValue) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.taskTotal) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.taskNoSubmit) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.taskSubmitted) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.taskPassed) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.taskNoPassed) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.studentID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.`class`.isEmpty {
      try visitor.visitSingularStringField(value: self.`class`, fieldNumber: 2)
    }
    if !self.pass.isEmpty {
      try visitor.visitSingularStringField(value: self.pass, fieldNumber: 3)
    }
    if self.passValue != 0 {
      try visitor.visitSingularFloatField(value: self.passValue, fieldNumber: 4)
    }
    if self.taskTotal != 0 {
      try visitor.visitSingularInt64Field(value: self.taskTotal, fieldNumber: 5)
    }
    if self.taskNoSubmit != 0 {
      try visitor.visitSingularInt64Field(value: self.taskNoSubmit, fieldNumber: 6)
    }
    if self.taskSubmitted != 0 {
      try visitor.visitSingularInt64Field(value: self.taskSubmitted, fieldNumber: 7)
    }
    if self.taskPassed != 0 {
      try visitor.visitSingularInt64Field(value: self.taskPassed, fieldNumber: 8)
    }
    if self.taskNoPassed != 0 {
      try visitor.visitSingularInt64Field(value: self.taskNoPassed, fieldNumber: 9)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 10)
    }
    if self.studentID != 0 {
      try visitor.visitSingularInt64Field(value: self.studentID, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_StudentPassCount, rhs: GloryApi_StudentPassCount) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.`class` != rhs.`class` {return false}
    if lhs.pass != rhs.pass {return false}
    if lhs.passValue != rhs.passValue {return false}
    if lhs.taskTotal != rhs.taskTotal {return false}
    if lhs.taskNoSubmit != rhs.taskNoSubmit {return false}
    if lhs.taskSubmitted != rhs.taskSubmitted {return false}
    if lhs.taskPassed != rhs.taskPassed {return false}
    if lhs.taskNoPassed != rhs.taskNoPassed {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.studentID != rhs.studentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_CountTeacherTaskRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CountTeacherTaskRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_request"),
    2: .standard(proto: "system_name"),
    3: .standard(proto: "class_id"),
    4: .standard(proto: "begin_date"),
    5: .standard(proto: "end_date"),
    6: .same(proto: "name"),
    100: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseRequest) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.systemName) }()
      case 3: try { try decoder.decodeRepeatedInt64Field(value: &self.classID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.beginDate) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.endDate) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 100: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.systemName.isEmpty {
      try visitor.visitRepeatedStringField(value: self.systemName, fieldNumber: 2)
    }
    if !self.classID.isEmpty {
      try visitor.visitPackedInt64Field(value: self.classID, fieldNumber: 3)
    }
    if !self.beginDate.isEmpty {
      try visitor.visitSingularStringField(value: self.beginDate, fieldNumber: 4)
    }
    if !self.endDate.isEmpty {
      try visitor.visitSingularStringField(value: self.endDate, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_CountTeacherTaskRequest, rhs: GloryApi_CountTeacherTaskRequest) -> Bool {
    if lhs._baseRequest != rhs._baseRequest {return false}
    if lhs.systemName != rhs.systemName {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.beginDate != rhs.beginDate {return false}
    if lhs.endDate != rhs.endDate {return false}
    if lhs.name != rhs.name {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_CountClassSubmitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CountClassSubmitResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
    2: .same(proto: "legend"),
    3: .same(proto: "categories"),
    4: .standard(proto: "class_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.legend) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.categories) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.classData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.legend.isEmpty {
      try visitor.visitRepeatedStringField(value: self.legend, fieldNumber: 2)
    }
    if !self.categories.isEmpty {
      try visitor.visitRepeatedStringField(value: self.categories, fieldNumber: 3)
    }
    if !self.classData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.classData, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_CountClassSubmitResponse, rhs: GloryApi_CountClassSubmitResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs.legend != rhs.legend {return false}
    if lhs.categories != rhs.categories {return false}
    if lhs.classData != rhs.classData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_CountPositiveListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CountPositiveListResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
    3: .standard(proto: "positive_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.positiveList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.positiveList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.positiveList, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_CountPositiveListResponse, rhs: GloryApi_CountPositiveListResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs.positiveList != rhs.positiveList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_CountPotentialListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CountPotentialListResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
    4: .standard(proto: "potential_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.potentialList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.potentialList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.potentialList, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_CountPotentialListResponse, rhs: GloryApi_CountPotentialListResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs.potentialList != rhs.potentialList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_CountSubmitListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CountSubmitListResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
    2: .same(proto: "list"),
    100: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 100: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 2)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_CountSubmitListResponse, rhs: GloryApi_CountSubmitListResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs.list != rhs.list {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_CountPassListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CountPassListResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
    2: .same(proto: "list"),
    100: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 100: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 2)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_CountPassListResponse, rhs: GloryApi_CountPassListResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs.list != rhs.list {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_CountClassPassResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CountClassPassResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
    2: .same(proto: "legend"),
    3: .same(proto: "categories"),
    4: .standard(proto: "class_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.legend) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.categories) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.classData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.legend.isEmpty {
      try visitor.visitRepeatedStringField(value: self.legend, fieldNumber: 2)
    }
    if !self.categories.isEmpty {
      try visitor.visitRepeatedStringField(value: self.categories, fieldNumber: 3)
    }
    if !self.classData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.classData, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_CountClassPassResponse, rhs: GloryApi_CountClassPassResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs.legend != rhs.legend {return false}
    if lhs.categories != rhs.categories {return false}
    if lhs.classData != rhs.classData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_CountSuperStudentListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CountSuperStudentListResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
    3: .standard(proto: "super_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.superList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.superList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.superList, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_CountSuperStudentListResponse, rhs: GloryApi_CountSuperStudentListResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs.superList != rhs.superList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_CountLaggingStudentListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CountLaggingStudentListResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
    3: .standard(proto: "lagging_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.laggingList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.laggingList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.laggingList, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_CountLaggingStudentListResponse, rhs: GloryApi_CountLaggingStudentListResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs.laggingList != rhs.laggingList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_CountClassSubmitListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CountClassSubmitListResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
    2: .same(proto: "list"),
    100: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 100: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 2)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_CountClassSubmitListResponse, rhs: GloryApi_CountClassSubmitListResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs.list != rhs.list {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_CountClassPassListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CountClassPassListResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
    2: .same(proto: "list"),
    100: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 100: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 2)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_CountClassPassListResponse, rhs: GloryApi_CountClassPassListResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs.list != rhs.list {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_TeacherTaskStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TeacherTaskStatsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseRequest) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_TeacherTaskStatsRequest, rhs: GloryApi_TeacherTaskStatsRequest) -> Bool {
    if lhs._baseRequest != rhs._baseRequest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_TeacherTaskStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TeacherTaskStatsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
    2: .standard(proto: "total_task_count"),
    3: .standard(proto: "not_started_count"),
    4: .standard(proto: "ongoing_count"),
    5: .standard(proto: "ended_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.totalTaskCount) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.notStartedCount) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.ongoingCount) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.endedCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.totalTaskCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalTaskCount, fieldNumber: 2)
    }
    if self.notStartedCount != 0 {
      try visitor.visitSingularInt64Field(value: self.notStartedCount, fieldNumber: 3)
    }
    if self.ongoingCount != 0 {
      try visitor.visitSingularInt64Field(value: self.ongoingCount, fieldNumber: 4)
    }
    if self.endedCount != 0 {
      try visitor.visitSingularInt64Field(value: self.endedCount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_TeacherTaskStatsResponse, rhs: GloryApi_TeacherTaskStatsResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs.totalTaskCount != rhs.totalTaskCount {return false}
    if lhs.notStartedCount != rhs.notStartedCount {return false}
    if lhs.ongoingCount != rhs.ongoingCount {return false}
    if lhs.endedCount != rhs.endedCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_ListTaskStudentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTaskStudentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_request"),
    2: .standard(proto: "task_id"),
    3: .standard(proto: "no_submit_class_id"),
    4: .standard(proto: "submitted_class_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseRequest) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.taskID) }()
      case 3: try { try decoder.decodeRepeatedInt64Field(value: &self.noSubmitClassID) }()
      case 4: try { try decoder.decodeRepeatedInt64Field(value: &self.submittedClassID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.taskID != 0 {
      try visitor.visitSingularInt64Field(value: self.taskID, fieldNumber: 2)
    }
    if !self.noSubmitClassID.isEmpty {
      try visitor.visitPackedInt64Field(value: self.noSubmitClassID, fieldNumber: 3)
    }
    if !self.submittedClassID.isEmpty {
      try visitor.visitPackedInt64Field(value: self.submittedClassID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_ListTaskStudentRequest, rhs: GloryApi_ListTaskStudentRequest) -> Bool {
    if lhs._baseRequest != rhs._baseRequest {return false}
    if lhs.taskID != rhs.taskID {return false}
    if lhs.noSubmitClassID != rhs.noSubmitClassID {return false}
    if lhs.submittedClassID != rhs.submittedClassID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_TaskStudent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TaskStudent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "task_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.taskID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.taskID != 0 {
      try visitor.visitSingularInt64Field(value: self.taskID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_TaskStudent, rhs: GloryApi_TaskStudent) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.taskID != rhs.taskID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_ListTaskStudentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTaskStudentResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
    2: .standard(proto: "no_submit_list"),
    3: .standard(proto: "submitted_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.noSubmitList) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.submittedList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.noSubmitList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.noSubmitList, fieldNumber: 2)
    }
    if !self.submittedList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.submittedList, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_ListTaskStudentResponse, rhs: GloryApi_ListTaskStudentResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs.noSubmitList != rhs.noSubmitList {return false}
    if lhs.submittedList != rhs.submittedList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
