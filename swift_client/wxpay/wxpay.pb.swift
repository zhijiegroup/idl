// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: wxpay/wxpay.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct GloryApi_WXPayInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///必传
  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  ///商户系统内部订单号，只能是数字、大小写字母_-*且在同一个商户号下唯一
  var outTradeNo: String {
    get {return _storage._outTradeNo}
    set {_uniqueStorage()._outTradeNo = newValue}
  }

  var amount: GloryApi_Amount {
    get {return _storage._amount ?? GloryApi_Amount()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {_uniqueStorage()._amount = nil}

  /// 信开放平台审核通过的移动应用appid
  var appid: String {
    get {return _storage._appid}
    set {_uniqueStorage()._appid = newValue}
  }

  ///非必传
  var attach: String {
    get {return _storage._attach}
    set {_uniqueStorage()._attach = newValue}
  }

  ///订单优惠标记
  var goodsTag: String {
    get {return _storage._goodsTag}
    set {_uniqueStorage()._goodsTag = newValue}
  }

  ///电子发票入口开放标识 传入true时，支付成功消息和支付详情页将出现开票入口。需要在微信支付商户平台或微信公众平台开通电子发票功能，传此字段才可生效
  var supportFapiao: Bool {
    get {return _storage._supportFapiao}
    set {_uniqueStorage()._supportFapiao = newValue}
  }

  ///优惠功能
  var detail: GloryApi_Detail {
    get {return _storage._detail ?? GloryApi_Detail()}
    set {_uniqueStorage()._detail = newValue}
  }
  /// Returns true if `detail` has been explicitly set.
  var hasDetail: Bool {return _storage._detail != nil}
  /// Clears the value of `detail`. Subsequent reads from it will return its default value.
  mutating func clearDetail() {_uniqueStorage()._detail = nil}

  ///支付场景描述
  var sceneInfo: GloryApi_SceneInfo {
    get {return _storage._sceneInfo ?? GloryApi_SceneInfo()}
    set {_uniqueStorage()._sceneInfo = newValue}
  }
  /// Returns true if `sceneInfo` has been explicitly set.
  var hasSceneInfo: Bool {return _storage._sceneInfo != nil}
  /// Clears the value of `sceneInfo`. Subsequent reads from it will return its default value.
  mutating func clearSceneInfo() {_uniqueStorage()._sceneInfo = nil}

  /// 结算信息
  var settleInfo: GloryApi_SettleInfo {
    get {return _storage._settleInfo ?? GloryApi_SettleInfo()}
    set {_uniqueStorage()._settleInfo = newValue}
  }
  /// Returns true if `settleInfo` has been explicitly set.
  var hasSettleInfo: Bool {return _storage._settleInfo != nil}
  /// Clears the value of `settleInfo`. Subsequent reads from it will return its default value.
  mutating func clearSettleInfo() {_uniqueStorage()._settleInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct GloryApi_Amount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///订单总金额，单位为分。
  var total: Int64 = 0

  ///CNY：人民币，境内商户号仅支持人民币
  var currency: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GloryApi_Detail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///订单原价
  var costPrice: Int64 = 0

  ///商品小票ID
  var invoiceID: String = String()

  ///单品列表
  var goodsDetail: [GloryApi_GoodsDetail] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GloryApi_GoodsDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///商户侧商品编码
  var merchantGoodsID: String = String()

  ///微信支付商品编码
  var wechatpayGoodsID: String = String()

  ///商品名称
  var goodsName: String = String()

  ///商品数量
  var quantity: Int64 = 0

  ///商品单价
  var unitPrice: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GloryApi_SceneInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///用户终端IP
  var payerClientIp: String = String()

  ///商户端设备号
  var deviceID: String = String()

  ///商户门店信息
  var storeInfo: GloryApi_StoreInfo {
    get {return _storeInfo ?? GloryApi_StoreInfo()}
    set {_storeInfo = newValue}
  }
  /// Returns true if `storeInfo` has been explicitly set.
  var hasStoreInfo: Bool {return self._storeInfo != nil}
  /// Clears the value of `storeInfo`. Subsequent reads from it will return its default value.
  mutating func clearStoreInfo() {self._storeInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storeInfo: GloryApi_StoreInfo? = nil
}

struct GloryApi_StoreInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///门店编号
  var id: String = String()

  ///门店名称
  var name: String = String()

  ///地区编码
  var areaCode: String = String()

  ///详细地址
  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GloryApi_SettleInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///是否指定分账
  var profitSharing: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GloryApi_PayerAmount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///CNY：人民币，境内商户号仅支持人民币
  var currency: String = String()

  var payerTotal: Int64 = 0

  var total: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GloryApi_Payer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var openid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GloryApi_WxOderInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appid: String = String()

  var attach: String = String()

  var bankType: String = String()

  var mchid: String = String()

  var outTradeNo: String = String()

  var successTime: String = String()

  var tradeState: String = String()

  var tradeStateDesc: String = String()

  var tradeType: String = String()

  var transactionID: String = String()

  var amount: GloryApi_PayerAmount {
    get {return _amount ?? GloryApi_PayerAmount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var payer: GloryApi_Payer {
    get {return _payer ?? GloryApi_Payer()}
    set {_payer = newValue}
  }
  /// Returns true if `payer` has been explicitly set.
  var hasPayer: Bool {return self._payer != nil}
  /// Clears the value of `payer`. Subsequent reads from it will return its default value.
  mutating func clearPayer() {self._payer = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: GloryApi_PayerAmount? = nil
  fileprivate var _payer: GloryApi_Payer? = nil
}

struct GloryApi_PrepayRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseRequest: Base_BaseRequest {
    get {return _baseRequest ?? Base_BaseRequest()}
    set {_baseRequest = newValue}
  }
  /// Returns true if `baseRequest` has been explicitly set.
  var hasBaseRequest: Bool {return self._baseRequest != nil}
  /// Clears the value of `baseRequest`. Subsequent reads from it will return its default value.
  mutating func clearBaseRequest() {self._baseRequest = nil}

  var payInfo: GloryApi_WXPayInfo {
    get {return _payInfo ?? GloryApi_WXPayInfo()}
    set {_payInfo = newValue}
  }
  /// Returns true if `payInfo` has been explicitly set.
  var hasPayInfo: Bool {return self._payInfo != nil}
  /// Clears the value of `payInfo`. Subsequent reads from it will return its default value.
  mutating func clearPayInfo() {self._payInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseRequest: Base_BaseRequest? = nil
  fileprivate var _payInfo: GloryApi_WXPayInfo? = nil
}

struct GloryApi_PrepayResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  ///预支付交易会话标识
  var prepayID: String = String()

  ///商户号 商户号mchid对应的值
  var partnerid: String = String()

  ///订单详情扩展字符串 暂填写固定值Sign=WXPay
  var package: String = String()

  ///随机字符串
  var noncestr: String = String()

  ///时间戳
  var timestamp: String = String()

  ///签名
  var sign: String = String()

  ///应用ID
  var appid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
}

struct GloryApi_CloseOrderRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseRequest: Base_BaseRequest {
    get {return _baseRequest ?? Base_BaseRequest()}
    set {_baseRequest = newValue}
  }
  /// Returns true if `baseRequest` has been explicitly set.
  var hasBaseRequest: Bool {return self._baseRequest != nil}
  /// Clears the value of `baseRequest`. Subsequent reads from it will return its default value.
  mutating func clearBaseRequest() {self._baseRequest = nil}

  ///商户订单号
  var outTradeNo: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseRequest: Base_BaseRequest? = nil
}

struct GloryApi_CloseOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  var statusCode: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
}

struct GloryApi_QueryOrderByIdRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseRequest: Base_BaseRequest {
    get {return _baseRequest ?? Base_BaseRequest()}
    set {_baseRequest = newValue}
  }
  /// Returns true if `baseRequest` has been explicitly set.
  var hasBaseRequest: Bool {return self._baseRequest != nil}
  /// Clears the value of `baseRequest`. Subsequent reads from it will return its default value.
  mutating func clearBaseRequest() {self._baseRequest = nil}

  ///微信支付订单号
  var transactionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseRequest: Base_BaseRequest? = nil
}

struct GloryApi_QueryOrderByIdResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  var orderInfo: GloryApi_WxOderInfo {
    get {return _orderInfo ?? GloryApi_WxOderInfo()}
    set {_orderInfo = newValue}
  }
  /// Returns true if `orderInfo` has been explicitly set.
  var hasOrderInfo: Bool {return self._orderInfo != nil}
  /// Clears the value of `orderInfo`. Subsequent reads from it will return its default value.
  mutating func clearOrderInfo() {self._orderInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
  fileprivate var _orderInfo: GloryApi_WxOderInfo? = nil
}

struct GloryApi_QueryOrderByOutTradeNoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseRequest: Base_BaseRequest {
    get {return _baseRequest ?? Base_BaseRequest()}
    set {_baseRequest = newValue}
  }
  /// Returns true if `baseRequest` has been explicitly set.
  var hasBaseRequest: Bool {return self._baseRequest != nil}
  /// Clears the value of `baseRequest`. Subsequent reads from it will return its default value.
  mutating func clearBaseRequest() {self._baseRequest = nil}

  ///商户订单号
  var outTradeNo: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseRequest: Base_BaseRequest? = nil
}

struct GloryApi_QueryOrderByOutTradeNoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseResp: Base_BaseResponse {
    get {return _baseResp ?? Base_BaseResponse()}
    set {_baseResp = newValue}
  }
  /// Returns true if `baseResp` has been explicitly set.
  var hasBaseResp: Bool {return self._baseResp != nil}
  /// Clears the value of `baseResp`. Subsequent reads from it will return its default value.
  mutating func clearBaseResp() {self._baseResp = nil}

  var orderInfo: GloryApi_WxOderInfo {
    get {return _orderInfo ?? GloryApi_WxOderInfo()}
    set {_orderInfo = newValue}
  }
  /// Returns true if `orderInfo` has been explicitly set.
  var hasOrderInfo: Bool {return self._orderInfo != nil}
  /// Clears the value of `orderInfo`. Subsequent reads from it will return its default value.
  mutating func clearOrderInfo() {self._orderInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseResp: Base_BaseResponse? = nil
  fileprivate var _orderInfo: GloryApi_WxOderInfo? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension GloryApi_WXPayInfo: @unchecked Sendable {}
extension GloryApi_Amount: @unchecked Sendable {}
extension GloryApi_Detail: @unchecked Sendable {}
extension GloryApi_GoodsDetail: @unchecked Sendable {}
extension GloryApi_SceneInfo: @unchecked Sendable {}
extension GloryApi_StoreInfo: @unchecked Sendable {}
extension GloryApi_SettleInfo: @unchecked Sendable {}
extension GloryApi_PayerAmount: @unchecked Sendable {}
extension GloryApi_Payer: @unchecked Sendable {}
extension GloryApi_WxOderInfo: @unchecked Sendable {}
extension GloryApi_PrepayRequest: @unchecked Sendable {}
extension GloryApi_PrepayResponse: @unchecked Sendable {}
extension GloryApi_CloseOrderRequest: @unchecked Sendable {}
extension GloryApi_CloseOrderResponse: @unchecked Sendable {}
extension GloryApi_QueryOrderByIdRequest: @unchecked Sendable {}
extension GloryApi_QueryOrderByIdResponse: @unchecked Sendable {}
extension GloryApi_QueryOrderByOutTradeNoRequest: @unchecked Sendable {}
extension GloryApi_QueryOrderByOutTradeNoResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "glory_api"

extension GloryApi_WXPayInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WXPayInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
    2: .standard(proto: "out_trade_no"),
    3: .same(proto: "amount"),
    10: .same(proto: "appid"),
    4: .same(proto: "attach"),
    5: .standard(proto: "goods_tag"),
    6: .standard(proto: "support_fapiao"),
    7: .same(proto: "detail"),
    8: .standard(proto: "scene_info"),
    9: .standard(proto: "settle_info"),
  ]

  fileprivate class _StorageClass {
    var _description_p: String = String()
    var _outTradeNo: String = String()
    var _amount: GloryApi_Amount? = nil
    var _appid: String = String()
    var _attach: String = String()
    var _goodsTag: String = String()
    var _supportFapiao: Bool = false
    var _detail: GloryApi_Detail? = nil
    var _sceneInfo: GloryApi_SceneInfo? = nil
    var _settleInfo: GloryApi_SettleInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _description_p = source._description_p
      _outTradeNo = source._outTradeNo
      _amount = source._amount
      _appid = source._appid
      _attach = source._attach
      _goodsTag = source._goodsTag
      _supportFapiao = source._supportFapiao
      _detail = source._detail
      _sceneInfo = source._sceneInfo
      _settleInfo = source._settleInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._outTradeNo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._amount) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._attach) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._goodsTag) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._supportFapiao) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._detail) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._sceneInfo) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._settleInfo) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._appid) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 1)
      }
      if !_storage._outTradeNo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._outTradeNo, fieldNumber: 2)
      }
      try { if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._attach.isEmpty {
        try visitor.visitSingularStringField(value: _storage._attach, fieldNumber: 4)
      }
      if !_storage._goodsTag.isEmpty {
        try visitor.visitSingularStringField(value: _storage._goodsTag, fieldNumber: 5)
      }
      if _storage._supportFapiao != false {
        try visitor.visitSingularBoolField(value: _storage._supportFapiao, fieldNumber: 6)
      }
      try { if let v = _storage._detail {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._sceneInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._settleInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._appid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appid, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_WXPayInfo, rhs: GloryApi_WXPayInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._outTradeNo != rhs_storage._outTradeNo {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._appid != rhs_storage._appid {return false}
        if _storage._attach != rhs_storage._attach {return false}
        if _storage._goodsTag != rhs_storage._goodsTag {return false}
        if _storage._supportFapiao != rhs_storage._supportFapiao {return false}
        if _storage._detail != rhs_storage._detail {return false}
        if _storage._sceneInfo != rhs_storage._sceneInfo {return false}
        if _storage._settleInfo != rhs_storage._settleInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_Amount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Amount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "currency"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.currency) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 1)
    }
    if !self.currency.isEmpty {
      try visitor.visitSingularStringField(value: self.currency, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_Amount, rhs: GloryApi_Amount) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.currency != rhs.currency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_Detail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Detail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cost_price"),
    2: .standard(proto: "invoice_id"),
    3: .standard(proto: "goods_detail"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.costPrice) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.invoiceID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.goodsDetail) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.costPrice != 0 {
      try visitor.visitSingularInt64Field(value: self.costPrice, fieldNumber: 1)
    }
    if !self.invoiceID.isEmpty {
      try visitor.visitSingularStringField(value: self.invoiceID, fieldNumber: 2)
    }
    if !self.goodsDetail.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.goodsDetail, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_Detail, rhs: GloryApi_Detail) -> Bool {
    if lhs.costPrice != rhs.costPrice {return false}
    if lhs.invoiceID != rhs.invoiceID {return false}
    if lhs.goodsDetail != rhs.goodsDetail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_GoodsDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GoodsDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "merchant_goods_id"),
    2: .standard(proto: "wechatpay_goods_id"),
    3: .standard(proto: "goods_name"),
    4: .same(proto: "quantity"),
    5: .standard(proto: "unit_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.merchantGoodsID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.wechatpayGoodsID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.goodsName) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.quantity) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.unitPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.merchantGoodsID.isEmpty {
      try visitor.visitSingularStringField(value: self.merchantGoodsID, fieldNumber: 1)
    }
    if !self.wechatpayGoodsID.isEmpty {
      try visitor.visitSingularStringField(value: self.wechatpayGoodsID, fieldNumber: 2)
    }
    if !self.goodsName.isEmpty {
      try visitor.visitSingularStringField(value: self.goodsName, fieldNumber: 3)
    }
    if self.quantity != 0 {
      try visitor.visitSingularInt64Field(value: self.quantity, fieldNumber: 4)
    }
    if self.unitPrice != 0 {
      try visitor.visitSingularInt64Field(value: self.unitPrice, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_GoodsDetail, rhs: GloryApi_GoodsDetail) -> Bool {
    if lhs.merchantGoodsID != rhs.merchantGoodsID {return false}
    if lhs.wechatpayGoodsID != rhs.wechatpayGoodsID {return false}
    if lhs.goodsName != rhs.goodsName {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.unitPrice != rhs.unitPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_SceneInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SceneInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payer_client_ip"),
    2: .standard(proto: "device_id"),
    3: .standard(proto: "store_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.payerClientIp) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._storeInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.payerClientIp.isEmpty {
      try visitor.visitSingularStringField(value: self.payerClientIp, fieldNumber: 1)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 2)
    }
    try { if let v = self._storeInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_SceneInfo, rhs: GloryApi_SceneInfo) -> Bool {
    if lhs.payerClientIp != rhs.payerClientIp {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs._storeInfo != rhs._storeInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_StoreInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoreInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "area_code"),
    4: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.areaCode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.areaCode.isEmpty {
      try visitor.visitSingularStringField(value: self.areaCode, fieldNumber: 3)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_StoreInfo, rhs: GloryApi_StoreInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.areaCode != rhs.areaCode {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_SettleInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SettleInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "profit_sharing"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.profitSharing) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.profitSharing != false {
      try visitor.visitSingularBoolField(value: self.profitSharing, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_SettleInfo, rhs: GloryApi_SettleInfo) -> Bool {
    if lhs.profitSharing != rhs.profitSharing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_PayerAmount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PayerAmount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currency"),
    2: .standard(proto: "payer_total"),
    3: .same(proto: "total"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.currency) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.payerTotal) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currency.isEmpty {
      try visitor.visitSingularStringField(value: self.currency, fieldNumber: 1)
    }
    if self.payerTotal != 0 {
      try visitor.visitSingularInt64Field(value: self.payerTotal, fieldNumber: 2)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_PayerAmount, rhs: GloryApi_PayerAmount) -> Bool {
    if lhs.currency != rhs.currency {return false}
    if lhs.payerTotal != rhs.payerTotal {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_Payer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Payer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "openid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.openid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.openid.isEmpty {
      try visitor.visitSingularStringField(value: self.openid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_Payer, rhs: GloryApi_Payer) -> Bool {
    if lhs.openid != rhs.openid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_WxOderInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WxOderInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appid"),
    2: .same(proto: "attach"),
    3: .standard(proto: "bank_type"),
    4: .same(proto: "mchid"),
    5: .standard(proto: "out_trade_no"),
    6: .standard(proto: "success_time"),
    7: .standard(proto: "trade_state"),
    8: .standard(proto: "trade_state_desc"),
    9: .standard(proto: "trade_type"),
    10: .standard(proto: "transaction_id"),
    11: .same(proto: "amount"),
    12: .same(proto: "payer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.attach) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bankType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.mchid) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.outTradeNo) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.successTime) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.tradeState) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.tradeStateDesc) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.tradeType) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._payer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.appid.isEmpty {
      try visitor.visitSingularStringField(value: self.appid, fieldNumber: 1)
    }
    if !self.attach.isEmpty {
      try visitor.visitSingularStringField(value: self.attach, fieldNumber: 2)
    }
    if !self.bankType.isEmpty {
      try visitor.visitSingularStringField(value: self.bankType, fieldNumber: 3)
    }
    if !self.mchid.isEmpty {
      try visitor.visitSingularStringField(value: self.mchid, fieldNumber: 4)
    }
    if !self.outTradeNo.isEmpty {
      try visitor.visitSingularStringField(value: self.outTradeNo, fieldNumber: 5)
    }
    if !self.successTime.isEmpty {
      try visitor.visitSingularStringField(value: self.successTime, fieldNumber: 6)
    }
    if !self.tradeState.isEmpty {
      try visitor.visitSingularStringField(value: self.tradeState, fieldNumber: 7)
    }
    if !self.tradeStateDesc.isEmpty {
      try visitor.visitSingularStringField(value: self.tradeStateDesc, fieldNumber: 8)
    }
    if !self.tradeType.isEmpty {
      try visitor.visitSingularStringField(value: self.tradeType, fieldNumber: 9)
    }
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 10)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._payer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_WxOderInfo, rhs: GloryApi_WxOderInfo) -> Bool {
    if lhs.appid != rhs.appid {return false}
    if lhs.attach != rhs.attach {return false}
    if lhs.bankType != rhs.bankType {return false}
    if lhs.mchid != rhs.mchid {return false}
    if lhs.outTradeNo != rhs.outTradeNo {return false}
    if lhs.successTime != rhs.successTime {return false}
    if lhs.tradeState != rhs.tradeState {return false}
    if lhs.tradeStateDesc != rhs.tradeStateDesc {return false}
    if lhs.tradeType != rhs.tradeType {return false}
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs._payer != rhs._payer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_PrepayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PrepayRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_request"),
    2: .standard(proto: "pay_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseRequest) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._payInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._payInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_PrepayRequest, rhs: GloryApi_PrepayRequest) -> Bool {
    if lhs._baseRequest != rhs._baseRequest {return false}
    if lhs._payInfo != rhs._payInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_PrepayResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PrepayResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
    2: .standard(proto: "prepay_id"),
    3: .same(proto: "partnerid"),
    4: .same(proto: "package"),
    5: .same(proto: "noncestr"),
    6: .same(proto: "timestamp"),
    7: .same(proto: "sign"),
    8: .same(proto: "appid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.prepayID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.partnerid) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.package) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.noncestr) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.timestamp) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.sign) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.appid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.prepayID.isEmpty {
      try visitor.visitSingularStringField(value: self.prepayID, fieldNumber: 2)
    }
    if !self.partnerid.isEmpty {
      try visitor.visitSingularStringField(value: self.partnerid, fieldNumber: 3)
    }
    if !self.package.isEmpty {
      try visitor.visitSingularStringField(value: self.package, fieldNumber: 4)
    }
    if !self.noncestr.isEmpty {
      try visitor.visitSingularStringField(value: self.noncestr, fieldNumber: 5)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitSingularStringField(value: self.timestamp, fieldNumber: 6)
    }
    if !self.sign.isEmpty {
      try visitor.visitSingularStringField(value: self.sign, fieldNumber: 7)
    }
    if !self.appid.isEmpty {
      try visitor.visitSingularStringField(value: self.appid, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_PrepayResponse, rhs: GloryApi_PrepayResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs.prepayID != rhs.prepayID {return false}
    if lhs.partnerid != rhs.partnerid {return false}
    if lhs.package != rhs.package {return false}
    if lhs.noncestr != rhs.noncestr {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.sign != rhs.sign {return false}
    if lhs.appid != rhs.appid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_CloseOrderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseOrderRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_request"),
    2: .standard(proto: "out_trade_no"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseRequest) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.outTradeNo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.outTradeNo.isEmpty {
      try visitor.visitSingularStringField(value: self.outTradeNo, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_CloseOrderRequest, rhs: GloryApi_CloseOrderRequest) -> Bool {
    if lhs._baseRequest != rhs._baseRequest {return false}
    if lhs.outTradeNo != rhs.outTradeNo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_CloseOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseOrderResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
    2: .standard(proto: "status_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.statusCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.statusCode != 0 {
      try visitor.visitSingularInt64Field(value: self.statusCode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_CloseOrderResponse, rhs: GloryApi_CloseOrderResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs.statusCode != rhs.statusCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_QueryOrderByIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOrderByIdRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_request"),
    2: .standard(proto: "transaction_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseRequest) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_QueryOrderByIdRequest, rhs: GloryApi_QueryOrderByIdRequest) -> Bool {
    if lhs._baseRequest != rhs._baseRequest {return false}
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_QueryOrderByIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOrderByIdResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
    2: .same(proto: "orderInfo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._orderInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._orderInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_QueryOrderByIdResponse, rhs: GloryApi_QueryOrderByIdResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs._orderInfo != rhs._orderInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_QueryOrderByOutTradeNoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOrderByOutTradeNoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_request"),
    2: .standard(proto: "out_trade_no"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseRequest) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.outTradeNo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.outTradeNo.isEmpty {
      try visitor.visitSingularStringField(value: self.outTradeNo, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_QueryOrderByOutTradeNoRequest, rhs: GloryApi_QueryOrderByOutTradeNoRequest) -> Bool {
    if lhs._baseRequest != rhs._baseRequest {return false}
    if lhs.outTradeNo != rhs.outTradeNo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GloryApi_QueryOrderByOutTradeNoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOrderByOutTradeNoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_resp"),
    2: .same(proto: "orderInfo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseResp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._orderInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseResp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._orderInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GloryApi_QueryOrderByOutTradeNoResponse, rhs: GloryApi_QueryOrderByOutTradeNoResponse) -> Bool {
    if lhs._baseResp != rhs._baseResp {return false}
    if lhs._orderInfo != rhs._orderInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
